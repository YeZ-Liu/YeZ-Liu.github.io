---
layout: post
title: '进程管理与调度'
date: 2022-9-29
author: 叶藏也不行
tags: Linux内核
---

> 《深入Linux内核加架构》进程管理与调度相关笔记

### 进程管理相关的系统调用

-  命令空间层次化机制，pid类型创建与管理等

-  fork, vfork, clone系统调用
-  写时复制COW技术，父子进程共享物理内存页，标记页表，要写一页就复制一页
-  NPTL（Native POSIX Threads Library），用户空间线程库，尽管内核提供线程机制，但是用户空间需要线程库才能使用
-  大部分工作由体系无关函数do_fork实现
-  thread_info和task_struct的关系，前者一般占两个内存页，包含内核栈以及体系结构特定的线程相关信息
-  sys_futex()，快速的用户空间互斥量；
-  内核线程，内核函数以进程的方式并行运行；kernel_thread函数；内核线程不可修改用户空间部分内容（随机的用户空间进程内容）；为强调用户空间部分不能问，mm设置为空指针。但由于内核必须知道用户空间当前包含了什么，所以在active_mm中保存了指向mm_struct的一个指针来描述它  
-  execve系统调用启动新程序；可执行程序格式，ELF格式；
-  exit系统调用终止进程；编译器在main函数末尾自动添加该调用；资源释放；

### 调度器的实现

-  调度策略，上下文切换；
-  红黑树可运行队列；虚拟时间与实时时间；
-  调度器类sched_class实现不同的调度策略；就绪队列run queue，每个CPU都有一个，一个进程只在一个rq上；
-  调度实体sched_entity；
-  实时互斥量问题RT-Mutex；
-  惰性TLB；
-  上下文切换的复杂，需要三个参数传递两个变量，因为上下文切换涉及三个进程；
-  惰性FPU模式，内核不使用的寄存器如浮点寄存器，不会保存和恢复除非有使用；

### 完全公平调度类

-  虚拟时钟的模拟；越重要的进程会有越高的优先级，更大的权重，累加的虚拟运行时间更小；
-  在运行队列红黑树中，虚拟时钟总是增加，活动进程总是向右移动，越重要的移动越慢，因此总是倾向于保持在队列前面；睡眠进程虚拟时钟保持不变，而队列最小虚拟时钟总是单调递增，睡眠进程醒来后在红黑树中的位置更靠左（键值计算方式为虚拟时钟减去队列最小虚拟时钟），被调度的机会也变大；
-  延迟跟踪，调度延迟，即保证每个可运行进程都至少运行一次的某个时间间隔；
-  抢占进程，确保被强占进程执行一定的时间，不至于切换频繁；

### 实时调度类

-  循环进程、先进先出进程；

### 调度器增强

-  SMP调度，负载均衡，亲和性，进程迁移，
-  调度域和控制组（cgoups)；
-  内核抢占和低延迟相关工作；不仅用户空间应用程序可被中断，内核也会被中断；thread_info中的抢占计数器来防止两个处理器在同一个临界区工作；内核代码检查长时间运行的函数，并在适当之处插入cond_resched调用；
-  TASK_KILLABLE状态，进程睡眠，但不响应非致命信号，可以被致命信号杀死；

